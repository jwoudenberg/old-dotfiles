#!/usr/bin/env node
var fs = require('fs');
var path = require('path');
var format = require('util').format;

//Keys are paths, values files in ./dotfiles that will be mapped there.
var linkMap = {
    '~/.bashrc':                    'bashrc',
    '~/.bash_profile':              'bash_profile',
    '~/.local/share/fonts':         'fonts',
    '~/.gitconfig':                 'gitconfig',
    '~/.vim':                       'vim',
    '~/.vimrc':                     'vimrc',
    '~/.xinitrc':                   'xinitrc',
    '~/.xmodmap':                   'xmodmap',
    '~/.Xresources':                'Xresources',
    '~/.config/awesome/rc.lua':     'awesome-rc.lua',
    '~/.config/fish/config.fish':   'config.fish',
    '~/.config/fish/functions':     'fish-functions'
};

var paths = Object.keys(linkMap);
paths.forEach(function (relDestination) {
    var fileName = linkMap[relDestination];
    var source = path.join(__dirname, fileName);
    //Bail if the source doesn't exist.
    if (!fs.existsSync(source)) {
        return console.log(format(
            '%s cannot be found in dotfiles. Skipping it.',
            fileName
        ));
    }
    var home = process.env.HOME;
    //node cannot deal with ~ paths. Get the full destination path.
    var destination = relDestination.replace(/^~/, home);
    //Create a readable version of the source path, for loggin.
    var relSource = source.replace(home, '~');
    if (fs.existsSync(destination)) {
        if (fs.lstatSync(destination).isSymbolicLink()) {
            fs.unlinkSync(destination);
        }
        else {
            return console.log(format(
                '%s already exists. Skipping linking of %s.',
                relDestination,
                fileName
            ));
        }
    }
    console.log(format(
        'linking %s -> %s',
        relSource,
        relDestination
    ));
    fs.symlinkSync(source, destination);
});
